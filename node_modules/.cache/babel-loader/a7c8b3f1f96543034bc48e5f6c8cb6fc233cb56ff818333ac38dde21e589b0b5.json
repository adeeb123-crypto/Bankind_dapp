{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Breakpoints = exports.BreakpointConstraint = void 0;\nvar _Utils = require(\"./Utils\");\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction breakpointKey(breakpoint) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint;\n}\nvar BreakpointConstraint;\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\n\nexports.BreakpointConstraint = BreakpointConstraint;\n(function (BreakpointConstraint) {\n  BreakpointConstraint[\"at\"] = \"at\";\n  BreakpointConstraint[\"lessThan\"] = \"lessThan\";\n  BreakpointConstraint[\"greaterThan\"] = \"greaterThan\";\n  BreakpointConstraint[\"greaterThanOrEqual\"] = \"greaterThanOrEqual\";\n  BreakpointConstraint[\"between\"] = \"between\";\n})(BreakpointConstraint || (exports.BreakpointConstraint = BreakpointConstraint = {}));\nvar Breakpoints = /*#__PURE__*/function () {\n  _createClass(Breakpoints, null, [{\n    key: \"validKeys\",\n    value: function validKeys() {\n      return [BreakpointConstraint.at, BreakpointConstraint.lessThan, BreakpointConstraint.greaterThan, BreakpointConstraint.greaterThanOrEqual, BreakpointConstraint.between];\n    }\n  }]);\n  function Breakpoints(_breakpoints) {\n    var _this = this,\n      _this$_mediaQueries;\n    _classCallCheck(this, Breakpoints);\n    _defineProperty(this, \"_sortedBreakpoints\", void 0);\n    _defineProperty(this, \"_breakpoints\", void 0);\n    _defineProperty(this, \"_mediaQueries\", void 0);\n    _defineProperty(this, \"findBreakpointsForWidths\", function (fromWidth, throughWidth) {\n      var fromBreakpoint = _this.findBreakpointAtWidth(fromWidth);\n      if (!fromBreakpoint) {\n        return undefined;\n      }\n      var throughBreakpoint = _this.findBreakpointAtWidth(throughWidth);\n      if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n        return [fromBreakpoint];\n      } else {\n        return _this._sortedBreakpoints.slice(_this._sortedBreakpoints.indexOf(fromBreakpoint), _this._sortedBreakpoints.indexOf(throughBreakpoint) + 1);\n      }\n    });\n    _defineProperty(this, \"findBreakpointAtWidth\", function (width) {\n      return _this._sortedBreakpoints.find(function (breakpoint, i) {\n        var nextBreakpoint = _this._sortedBreakpoints[i + 1];\n        if (nextBreakpoint) {\n          return width >= _this._breakpoints[breakpoint] && width < _this._breakpoints[nextBreakpoint];\n        } else {\n          return width >= _this._breakpoints[breakpoint];\n        }\n      });\n    });\n    _defineProperty(this, \"valuesWithBreakpointProps\", function (values) {\n      var max = values.length;\n      var valueBreakpoints = [];\n      var lastTuple;\n      _this._sortedBreakpoints.forEach(function (breakpoint, i) {\n        var value = values[i];\n        if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n          lastTuple = [value, [breakpoint]];\n          valueBreakpoints.push(lastTuple);\n        } else {\n          lastTuple[1].push(breakpoint);\n        }\n      });\n      return valueBreakpoints.map(function (_ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          value = _ref2[0],\n          breakpoints = _ref2[1];\n        var props = {};\n        if (i === valueBreakpoints.length - 1) {\n          props.greaterThanOrEqual = breakpoints[0];\n        } else if (breakpoints.length === 1) {\n          props.at = breakpoints[0];\n        } else {\n          // TODO: This is less than ideal, would be good to have a `through`\n          //       prop, which unlike `between` is inclusive.\n          props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]];\n        }\n        return [value, props];\n      });\n    });\n    this._breakpoints = _breakpoints;\n    this._sortedBreakpoints = Object.keys(_breakpoints).map(function (breakpoint) {\n      return [breakpoint, _breakpoints[breakpoint]];\n    }).sort(function (a, b) {\n      return a[1] < b[1] ? -1 : 1;\n    }).map(function (breakpointAndValue) {\n      return breakpointAndValue[0];\n    }); // List of all possible and valid `between` combinations\n\n    var betweenCombinations = this._sortedBreakpoints.slice(0, -1).reduce(function (acc, b1, i) {\n      return _toConsumableArray(acc).concat(_toConsumableArray(_this._sortedBreakpoints.slice(i + 1).map(function (b2) {\n        return [b1, b2];\n      })));\n    }, []);\n    this._mediaQueries = (_this$_mediaQueries = {}, _defineProperty(_this$_mediaQueries, BreakpointConstraint.at, this._createBreakpointQueries(BreakpointConstraint.at, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.lessThan, this._createBreakpointQueries(BreakpointConstraint.lessThan, this._sortedBreakpoints.slice(1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThan, this._createBreakpointQueries(BreakpointConstraint.greaterThan, this._sortedBreakpoints.slice(0, -1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThanOrEqual, this._createBreakpointQueries(BreakpointConstraint.greaterThanOrEqual, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.between, this._createBreakpointQueries(BreakpointConstraint.between, betweenCombinations)), _this$_mediaQueries);\n  }\n  _createClass(Breakpoints, [{\n    key: \"toVisibleAtBreakpointSet\",\n    value: function toVisibleAtBreakpointSet(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.lessThan;\n        });\n        return this.sortedBreakpoints.slice(0, breakpointIndex);\n      } else if (breakpointProps.greaterThan) {\n        var _breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThan;\n        });\n        return this.sortedBreakpoints.slice(_breakpointIndex + 1);\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _breakpointIndex2 = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThanOrEqual;\n        });\n        return this.sortedBreakpoints.slice(_breakpointIndex2);\n      } else if (breakpointProps.between) {\n        var between = breakpointProps.between;\n        var fromBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[0];\n        });\n        var toBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[1];\n        });\n        return this.sortedBreakpoints.slice(fromBreakpointIndex, toBreakpointIndex);\n      }\n      return [];\n    }\n  }, {\n    key: \"toRuleSets\",\n    value: function toRuleSets() {\n      var _this2 = this;\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Breakpoints.validKeys();\n      var selectedMediaQueries = keys.reduce(function (mediaQueries, query) {\n        mediaQueries[query] = _this2._mediaQueries[query];\n        return mediaQueries;\n      }, {});\n      return Object.entries(selectedMediaQueries).reduce(function (acc, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          type = _ref4[0],\n          queries = _ref4[1];\n        queries.forEach(function (query, breakpoint) {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push((0, _Utils.createRuleSet)((0, _Utils.createClassName)(type, breakpoint), \"not all and \".concat(query)));\n        });\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"shouldRenderMediaQuery\",\n    value: function shouldRenderMediaQuery(breakpointProps, onlyRenderAt) {\n      var _this3 = this;\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        var lowestAllowedWidth = Math.min.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return lowestAllowedWidth < width;\n      } else if (breakpointProps.greaterThan) {\n        var _width = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n        var highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return highestAllowedWidth >= _width;\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width2 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        var _highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return _highestAllowedWidth >= _width2;\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `oustide`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        var allowedWidths = onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        });\n        return !(Math.max.apply(Math, _toConsumableArray(allowedWidths)) < fromWidth || Math.min.apply(Math, _toConsumableArray(allowedWidths)) >= toWidth);\n      }\n      return false;\n    }\n  }, {\n    key: \"_normalizeProps\",\n    value: function _normalizeProps(breakpointProps) {\n      if (breakpointProps.at) {\n        var fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at);\n        var to = this._sortedBreakpoints[fromIndex + 1];\n        return to ? {\n          between: [breakpointProps.at, to]\n        } : {\n          greaterThanOrEqual: breakpointProps.at\n        };\n      }\n      return breakpointProps;\n    }\n  }, {\n    key: \"_createBreakpointQuery\",\n    value: function _createBreakpointQuery(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        return \"(max-width:\".concat(width - 0.02, \"px)\");\n      } else if (breakpointProps.greaterThan) {\n        var _width3 = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n        return \"(min-width:\".concat(_width3, \"px)\");\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width4 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        return \"(min-width:\".concat(_width4, \"px)\");\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `outside`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        return \"(min-width:\".concat(fromWidth, \"px) and (max-width:\").concat(toWidth - 0.02, \"px)\");\n      }\n      throw new Error(\"Unexpected breakpoint props: \".concat(JSON.stringify(breakpointProps)));\n    }\n  }, {\n    key: \"_createBreakpointQueries\",\n    value: function _createBreakpointQueries(key, forBreakpoints) {\n      var _this4 = this;\n      return forBreakpoints.reduce(function (map, breakpoint) {\n        map.set(breakpointKey(breakpoint), _this4._createBreakpointQuery(_defineProperty({}, key, breakpoint)));\n        return map;\n      }, new Map());\n    }\n  }, {\n    key: \"_findNextBreakpoint\",\n    value: function _findNextBreakpoint(breakpoint) {\n      var nextBreakpoint = this._sortedBreakpoints[this._sortedBreakpoints.indexOf(breakpoint) + 1];\n      if (!nextBreakpoint) {\n        throw new Error(\"There is no breakpoint larger than \".concat(breakpoint));\n      }\n      return nextBreakpoint;\n    }\n  }, {\n    key: \"sortedBreakpoints\",\n    get: function get() {\n      return this._sortedBreakpoints;\n    }\n  }, {\n    key: \"dynamicResponsiveMediaQueries\",\n    get: function get() {\n      return Array.from(this._mediaQueries[BreakpointConstraint.at].entries()).reduce(function (acc, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n        return _objectSpread({}, acc, _defineProperty({}, k, v));\n      }, {});\n    }\n  }, {\n    key: \"largestBreakpoint\",\n    get: function get() {\n      return this._sortedBreakpoints[this._sortedBreakpoints.length - 1];\n    }\n  }]);\n  return Breakpoints;\n}();\nexports.Breakpoints = Breakpoints;","map":{"version":3,"mappings":"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","names":["breakpointKey","breakpoint","Array","isArray","join","BreakpointConstraint","Breakpoints","at","lessThan","greaterThan","greaterThanOrEqual","between","breakpoints","_this$_mediaQueries","_classCallCheck","_defineProperty","fromWidth","throughWidth","fromBreakpoint","_this","findBreakpointAtWidth","undefined","throughBreakpoint","_sortedBreakpoints","slice","indexOf","width","find","i","nextBreakpoint","_breakpoints","values","max","length","valueBreakpoints","lastTuple","forEach","value","push","map","props","Object","keys","sort","a","b","breakpointAndValue","betweenCombinations","reduce","acc","b1","b2","_mediaQueries","_createBreakpointQueries","breakpointProps","_normalizeProps","breakpointIndex","sortedBreakpoints","findIndex","bp","fromBreakpointIndex","toBreakpointIndex","validKeys","selectedMediaQueries","mediaQueries","query","_this2","entries","type","queries","onlyRenderAt","lowestAllowedWidth","Math","min","_this3","_findNextBreakpoint","highestAllowedWidth","toWidth","allowedWidths","fromIndex","to","Error","JSON","stringify","key","forBreakpoints","set","_this4","_createBreakpointQuery","Map","from","k","v"],"sources":["C:\\Users\\abdul.mohammed\\Work\\Learn\\lvl_6\\Banking_dapp\\BankingSystem_Dapp\\node_modules\\@artsy\\fresnel\\src\\Breakpoints.ts"],"sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toVisibleAtBreakpointSet(breakpointProps: MediaBreakpointProps) {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.lessThan\n      )\n      return this.sortedBreakpoints.slice(0, breakpointIndex)\n    } else if (breakpointProps.greaterThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThan\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex + 1)\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThanOrEqual\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex)\n    } else if (breakpointProps.between) {\n      const between = breakpointProps.between\n      const fromBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[0]\n      )\n      const toBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[1]\n      )\n      return this.sortedBreakpoints.slice(\n        fromBreakpointIndex,\n        toBreakpointIndex\n      )\n    }\n    return []\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): ValueBreakpointPropsTuple<SizeValue, BreakpointKey>[] => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 0.02}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 0.02}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}